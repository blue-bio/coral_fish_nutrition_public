---
title: "fnc_waterquailty"
format: html
editor: source
---

# Preparations
##Load packages
```{r Preperations}
#| label: libraries
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: false

library(tidyverse) #for data wrangling
library(cmdstanr)   #for cmdstan
library(brms)       #for fitting models in STAN
library(standist)   #for visualizing distributions
library(HDInterval) #for HPD intervals
library(posterior)  #for posterior draws
library(coda)       #for diagnostics
library(bayesplot)  #for diagnostics
library(ggmcmc)     #for MCMC diagnostics
library(rstan)      #for interfacing with STAN
library(effects)   #for partial effects plots
library(car)       #for regression diagnostics
library(broom)     #for tidy output
library(ggfortify) #for model diagnostics
library(sjPlot)    #for outputs
library(knitr)     #for kable
library(emmeans)   #for estimating marginal means
library(MASS)      #for glm.nb
library(MuMIn)     #for AICc
library(tidybayes)
library(broom.mixed)#for tidying MCMC outputs
library(patchwork)  #for multiple plots
library(ggeffects)
library(DHARMa)
library(ggridges)
library(bayestestR) #for ROPE
library(see)        #for some plots
library(easystats)  #framework for stats, modelling and visualisation 
library(dplyr)
library(scales)
library(stringr) 
```

##Read in data
```{r}
#| label: data_input
#| output: false
#| eval: true 
#| warning: false
#| message: false
#| cache: true

dislv_WQ <- read_csv('../data/D_WQ_full.csv', trim_ws = TRUE)
part_WQ <- read_csv('../data/P_WQ_full.csv', trim_ws = TRUE)

dislv_WQ <- dislv_WQ |> mutate(treatment = factor(Treatment),
                       sample = factor(Sample), 
                       DOC = as.numeric(DOC))   
part_WQ <- part_WQ |> mutate(treatment = factor(Treatment),
                       sample = factor(Sample)) 

dislv_WQ$tank_rep_rand <- paste(dislv_WQ$treatment, "_", dislv_WQ$Tank)
part_WQ$tank_rep_rand <- paste(part_WQ$treatment, "_", part_WQ$Tank)

dislv_WQ <- dislv_WQ |> mutate(tank_rep_rand = factor(tank_rep_rand),
                       tank = factor(Tank))   
part_WQ <- part_WQ |> mutate(tank_rep_rand = factor(tank_rep_rand),
                       tank = factor(Tank)) 

part_WQ <- part_WQ |> dplyr::filter(treatment!="Blank") |> droplevels() 
  #drop the Blank from part_WQ

dislv_WQ <- dislv_WQ |> mutate(NP = (NH4 + NO3NO2)/PO4)
#Make N/P Ratio

```

##Load models 
```{r}
#model outputs that were used in the manuscript
load("../models/WQ.NH4.brm4.RData")
load("../models/WQ.NO2.brm4.RData")
load("../models/WQ.NO3NO2.brm4.RData")
load("../models/WQ.PO4.brm4.RData")
load("../models/WQ.DOC.brm4.RData")
load("../models/WQ.PN.brm4.RData")
load("../models/WQ.PC.brm6.RData")
load("../models/WQ.PCN.brm4.RData")
load("../models/WQ.NP.brm2.RData")

```


#Visualisation
```{r}
#| label: Visualisation_set-up
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

level_order_wq <- c('Control', 'Dissolved_Coral', 'Dissolved_Fish', 'Fish', 'LiveFeeds', 'Mixed', 'Pellets') 
level_order_wq_new <- c('Control', 'Pellets', 'LiveFeeds', 'Dissolved_Coral', 'Dissolved_Fish', 'Fish',  'Mixed') 
group.colors_wq <- c(Control = "#999999", Dissolved_Coral = "#E69F00", Dissolved_Fish = "#D55E00" , Fish = "#56B4E9", LiveFeeds = "#009E73", Mixed = "#F0E442", Pellets = "#0072B2")

cbPalette_wq <- c("#999999", "#E69F00", "#D55E00", "#56B4E9", "#009E73", "#F0E442", "#0072B2")

wq_labels <- c('Control', 'Dissolved (Coral tank)', 'Dissolved (Fish tank)', 'Fish', 'LiveFeeds', 'Mix', 'Pellets')
wq_labels_new <- c('Control', 'Pellets', 'LiveFeeds', 'Dissolved (Coral tank)', 'Dissolved (Fish tank)', 'Fish',  'Mixed')

```

#NH4 
## Fit the model
###Treatment + 1|tank:sample random model 
####Priors model
```{r}
#| label: tank_samp_rand_model_1_NH4
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.NH4.form2 <- bf(NH4 ~ treatment + (1|tank_rep_rand:sample), family = Gamma(link = "log")) 

dislv_WQ |> group_by(treatment:tank_rep_rand:sample) |> summarise(median(log(NH4)), mad(log(NH4))) 

priors <- prior(normal(-2.1, 0.5), class = 'Intercept') + 
  prior(normal(0, 1.5), class = 'b') + 
  prior(student_t(3, 0, 0.5), class = 'sd') + 
  prior(gamma(0.01, 0.01), class = 'shape')

WQ.NH4.brm3 <- brm(WQ.NH4.form2, 
                 data = dislv_WQ,
                 prior = priors, 
                 sample_prior = 'only',
                 iter = 10000, 
                 warmup = 2500, 
                 chains = 3, cores = 3, 
                 thin = 10, 
                 refresh = 0, 
                 seed = 123, 
                 control = list(adapt_delta = 0.99, max_treedepth = 20),
                 backend = "cmdstan") 


WQ.NH4.brm3 |> conditional_effects("treatment") |> plot(points = TRUE)   
#OK
```

####With data
```{r}
#| label: tank_samp_rand_model_2_NH4
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.NH4.brm4 <- WQ.NH4.brm3 |> update(sample_prior = "yes",
                                       refresh = 0, 
                                       iter = 10000,
                                       warmup = 2500,
                                       seed = 123) 

WQ.NH4.brm4 |> conditional_effects("treatment") |> plot(points = TRUE)
#OK
```

####MCMC sampling diagnostics

```{r}
#| label: tank_samp_rand_model_3_NH4
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: true 
pars <- WQ.NH4.brm4 |> get_variables()
pars_2 <- str_extract(pars, '^b_.*|^shape$') |> na.omit() 

#Traceplots
WQ.NH4.brm4$fit |> stan_trace(pars = pars_2, inc_warmup = TRUE)
#good 

#Autocorrelation
WQ.NH4.brm4$fit |> stan_ac(pars = pars_2) 
#good

#Rhat
WQ.NH4.brm4$fit |> stan_rhat()
#good

#ESS
WQ.NH4.brm4$fit |> stan_ess() 
#OK

summary(WQ.NH4.brm4) 
#good 

```

####Posterior probablity checks
```{r}
#| label: tank_samp_rand_model_4_NH4
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.NH4.brm4 |> pp_check(type = 'dens_overlay', ndraws = 200) + theme_classic()
#Much better with gamma distribution! 
```

####DHARMA residuals

```{r}
#| label: tank_samp_rand_model_5_NH4
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.resids <- make_brms_dharma_res(WQ.NH4.brm4, integerResponse = FALSE)

wrap_elements(~testUniformity(WQ.resids)) + 
  wrap_elements(~plotResiduals(WQ.resids, form = factor(rep(1, nrow(dislv_WQ))))) +
  wrap_elements(~plotResiduals(WQ.resids, quantreg = FALSE)) +
  wrap_elements(~testDispersion(WQ.resids))
#Not good (with guassian(link = log), tank:sample rand eff)
#Try with gamma distribution

#Much better with gamma! 
#Still get a non-normal flag for QQ plot, but looking visually is acceptable. 
```

####Model Investigations 
#####Summary
```{r}
#| label: model_investigations_1_NH4
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.NH4.brm4 |> 
  as_draws_df() |> 
  dplyr::select(matches('^b_.*|^sigma$|^sd.*')) |> 
  mutate(across(everything(), exp)) |> 
  summarise_draws(median, 
                  ~ HDInterval::hdi(.x, .width = 0.95),  
                  Pl = ~ mean(.x < 1), 
                  Pg = ~ mean(.x > 1),
                  "rhat", 
                  "ess_bulk", 
                  "ess_tail") |>
  knitr::kable()  

```

#####Means plot

```{r}
#| label: model_investigations_2_NH4
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.NH4.means <- WQ.NH4.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

(WQ.NH4.means)

#make plot that displays mean and HDCI
WQ_NH4_plot <- ggplot(data = WQ.NH4.means, aes(x=factor(treatment, level = level_order_wq), y = response, colour = treatment)) + 
  geom_point(data = dislv_WQ, aes(x = factor(treatment, level = level_order_wq), y = NH4), colour = "black", alpha = 0.2, size = 0.5, position = position_jitter(w = 0.1, h = 0)) +
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15, colour = "black"), 
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(wq_labels, 12)) + 
  scale_y_continuous(expression(NH[4]~(µmol~L^-1)), 
                                limits = c(0, 1)) + 
  scale_colour_manual(values=group.colors_wq) 
```

#####Means plot-no raw data

```{r}
#| label: model_investigations_2_NH4_new
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.NH4.means <- WQ.NH4.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

(WQ.NH4.means)

#make plot that displays mean and HDCI
WQ_NH4_plot_new <- ggplot(data = WQ.NH4.means, aes(x=factor(treatment, level = level_order_wq_new), y = response, colour = treatment)) + 
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15, colour = "black"), 
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(wq_labels_new, 12)) + 
  scale_y_continuous(expression(NH[4]~(µmol~L^-1)), 
                                limits = c(0, 0.5)) + 
  scale_colour_manual(values=group.colors_wq) 
```

#####Pairwise comparisons
```{r}
#| label: model_investigations_5_NH4
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true
 
sTreat <- WQ.NH4.brm4$data |> pull(treatment) |> levels()
STreat <- rep(1, length(sTreat))
names(STreat) <- sTreat
WQ.NH4.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = exp(.value)) |> 
  #filter(.draw == 1, month == 1) |> 
  pull(.value) -> x
x %*% t(multcomp::contrMat(n = STreat, type = "Tukey"))


WQ.NH4.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = exp(.value)) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey"))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<0),
            Pg = mean(fit>0)) 
#absolute difference between the treatments within different months

WQ.NH4.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = log(exp(.value))) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = exp(t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey")))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<1),
            Pg = mean(fit>1))  
#this is the ratio growth in one treatment to another, with HDPI

```


#NO2 
## Fit the model

###Treatment + 1|tank:sample random model 
####Priors model
```{r}
#| label: tank_samp_rand_model_1_NO2
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.NO2.form2 <- bf(NO2 ~ treatment + (1|tank_rep_rand:sample), family = Gamma(link = "log"))
                    
priors <- prior(normal(-3.22, 0.9), class = 'Intercept') + 
  prior(normal(0, 0.8), class = 'b') + 
  prior(student_t(3, 0, 0.5), class = 'sd') + 
  prior(gamma(2, 1), class = 'shape')

WQ.NO2.brm3 <- brm(WQ.NO2.form2, 
                 data = dislv_WQ,
                 prior = priors, 
                 sample_prior = 'only',
                 iter = 5000, 
                 warmup = 2500, 
                 chains = 3, cores = 3, 
                 thin = 5, 
                 refresh = 0, 
                 seed = 123, 
                 control = list(adapt_delta = 0.99),
                 backend = "cmdstan") 


WQ.NO2.brm3 |> conditional_effects("treatment") |> plot(points = TRUE)   
#OK
```

####With data

```{r}
#| label: tank_samp_rand_model_2_NO2
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.NO2.brm4 <- WQ.NO2.brm3 |> update(sample_prior = "yes",
                                       refresh = 0, 
                                       iter = 5000,
                                       warmup = 2500,
                                       seed = 123) 

WQ.NO2.brm4 |> conditional_effects("treatment") |> plot(points = TRUE, jitter_width = 0.2)

```

####MCMC sampling diagnostics
```{r}
#| label: tank_samp_rand_model_3_NO2
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: true 
pars <- WQ.NO2.brm4 |> get_variables()
pars_2 <- str_extract(pars, '^b_.*|^sd_.*|^shape$') |> na.omit() 

#Traceplots
WQ.NO2.brm4$fit |> stan_trace(pars = pars_2, inc_warmup = TRUE)
#good 

#Autocorrelation
WQ.NO2.brm4$fit |> stan_ac(pars = pars_2) 
#good

#Rhat
WQ.NO2.brm4$fit |> stan_rhat()
#good

#ESS
WQ.NO2.brm4$fit |> stan_ess() 
#OK

summary(WQ.NO2.brm4) 
#good 
```

####Posterior probablity checks

```{r}
#| label: tank_samp_rand_model_4_NO2
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.NO2.brm4 |> pp_check(type = 'dens_overlay', ndraws = 200) + theme_classic()
```

####DHARMA residuals
```{r}
#| label: tank_samp_rand_model_5_NO2
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.resids <- make_brms_dharma_res(WQ.NO2.brm4, integerResponse = FALSE)

wrap_elements(~testUniformity(WQ.resids)) + 
  wrap_elements(~plotResiduals(WQ.resids, form = factor(rep(1, nrow(dislv_WQ))))) +
  wrap_elements(~plotResiduals(WQ.resids, quantreg = FALSE)) +
  wrap_elements(~testDispersion(WQ.resids))
# OK
```

####Model Investigations 
#####Summary
```{r}
#| label: model_investigations_1_NO2
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.NO2.brm4 |> 
  as_draws_df() |> 
  dplyr::select(matches('^b_.*|shape.*')) |> 
  mutate(across(everything(), exp)) |> 
  summarise_draws(median, 
                  ~ HDInterval::hdi(.x, .width = 0.95),  
                  Pl = ~ mean(.x < 1), 
                  Pg = ~ mean(.x > 1),
                  "rhat", 
                  "ess_bulk", 
                  "ess_tail") |>
  knitr::kable()  
```

#####Means plot

```{r}
#| label: model_investigations_2_NO2
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.NO2.means <- WQ.NO2.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

(WQ.NO2.means)

#make plot that displays mean and HDCI
WQ_NO2_plot <- ggplot(data = WQ.NO2.means, aes(x=factor(treatment, level = level_order_wq), y = response, colour = treatment)) + 
  geom_point(data = dislv_WQ, aes(x = treatment, y = NO2), colour = "black", alpha = 0.2, size = 0.5, position = position_jitter(w = 0.1, h = 0)) +
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15), 
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(wq_labels, 12)) + 
  scale_y_continuous(expression(NO[2]~(umol~L^-1))) + 
  scale_colour_manual(values=group.colors_wq) + 
  ggplot2::annotate(geom = "text", 
                    label = expression("NO"[2]), 
                    size = 5, 
                    x = 0.5, 
                    y = Inf, 
                    hjust = 0, 
                    vjust = 1)
```

#####Means plot-no raw data

```{r}
#| label: model_investigations_2_NO2_new
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.NO2.means <- WQ.NO2.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

#make plot that displays mean and HDCI
WQ_NO2_plot_new <- ggplot(data = WQ.NO2.means, aes(x=factor(treatment, level = level_order_wq_new), y = response, colour = treatment)) + 
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15, colour = "black"), 
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(wq_labels_new, 12)) + 
  scale_y_continuous(expression(NO[2]~(µmol~L^-1)), 
                                limits = c(0.04, 0.07)) + 
  scale_colour_manual(values=group.colors_wq) 
```

#####Pairwise investigations (Murray code)

```{r}
#| label: model_investigations_4_NO2
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

sTreat <- WQ.NO2.brm4$data |> pull(treatment) |> levels()
STreat <- rep(1, length(sTreat))
names(STreat) <- sTreat

WQ.NO2.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = exp(.value)) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey"))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<0),
            Pg = mean(fit>0)) 
#absolute difference between the treatments


WQ.NO2.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = log(exp(.value))) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = exp(t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey")))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<1),
            Pg = mean(fit>1))  
#this is the ratio of one treatment to another 
```

#NO2 + NO3 
## Fit the model

###Treatment + 1|tank:sample random model 
####Priors model
```{r}
#| label: tank_samp_rand_model_1_NO2NO3
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.NO3NO2.form2 <- bf(NO3NO2 ~ treatment + (1|tank_rep_rand:sample), family = Gamma(link = "log"))
                    
priors_NO3NO2 <- prior(normal(-0.28, 0.5), class = 'Intercept') + 
  prior(student_t(3, 0, 0.9), class = 'b') + 
  prior(student_t(3, 0, 0.4), class = 'sd') + 
  prior(gamma(2, 1), class = 'shape')

WQ.NO3NO2.brm3 <- brm(WQ.NO3NO2.form2, 
                 data = dislv_WQ,
                 prior = priors_NO3NO2, 
                 sample_prior = 'only',
                 iter = 5000, 
                 warmup = 2500, 
                 chains = 3, cores = 3, 
                 thin = 5, 
                 refresh = 0, 
                 seed = 123, 
                 control = list(adapt_delta = 0.99),
                 backend = "cmdstan") 


WQ.NO3NO2.brm3 |> conditional_effects("treatment") |> plot(points = TRUE)   
#OK
```

####With data
```{r}
#| label: tank_samp_rand_model_2_NO2NO3
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.NO3NO2.brm4 <- WQ.NO3NO2.brm3 |> update(sample_prior = "yes",
                                       refresh = 0, 
                                       iter = 5000,
                                       warmup = 2500,
                                       seed = 123) 

WQ.NO3NO2.brm4 |> conditional_effects("treatment") |> plot(points = TRUE, jitter_width = 0.2)
```

####MCMC sampling diagnostics

```{r}
#| label: tank_samp_rand_model_3_NO2NO3
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: true 
pars <- WQ.NO3NO2.brm4 |> get_variables()
pars_2 <- str_extract(pars, '^b_.*|^sd_.*|^shape$') |> na.omit() 

#Traceplots
WQ.NO3NO2.brm4$fit |> stan_trace(pars = pars_2, inc_warmup = TRUE)
#good 

#Autocorrelation
WQ.NO3NO2.brm4$fit |> stan_ac(pars = pars_2) 
#good

#Rhat
WQ.NO3NO2.brm4$fit |> stan_rhat()
#good

#ESS
WQ.NO3NO2.brm4$fit |> stan_ess() 
#OK

summary(WQ.NO3NO2.brm4) 
#good 

```

####Posterior probablity checks

```{r}
#| label: tank_samp_rand_model_4_NO2NO3
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.NO3NO2.brm4 |> pp_check(type = 'dens_overlay', ndraws = 200) + theme_classic()
#pretty good
```

####DHARMA residuals

```{r}
#| label: tank_samp_rand_model_5_NO2NO3
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.resids <- make_brms_dharma_res(WQ.NO3NO2.brm4, integerResponse = FALSE)

wrap_elements(~testUniformity(WQ.resids)) + 
  wrap_elements(~plotResiduals(WQ.resids, form = factor(rep(1, nrow(dislv_WQ))))) +
  wrap_elements(~plotResiduals(WQ.resids, quantreg = FALSE)) +
  wrap_elements(~testDispersion(WQ.resids))
```

####Model Investigations 
#####Summary
```{r}
#| label: model_investigations_1_NO2NO3
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.NO3NO2.brm4 |> 
  as_draws_df() |> 
  dplyr::select(matches('^b_.*|shape.*')) |> 
  mutate(across(everything(), exp)) |> 
  summarise_draws(median, 
                  ~ HDInterval::hdi(.x, .width = 0.95),  
                  Pl = ~ mean(.x < 1), 
                  Pg = ~ mean(.x > 1),
                  "rhat", 
                  "ess_bulk", 
                  "ess_tail") |>
  knitr::kable()  

```

#####Means plot
```{r}
#| label: model_investigations_2_NO2NO3
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.NO3NO2.means <- WQ.NO3NO2.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

#make plot that displays mean and HDCI
WQ_NO3NO2_plot <- ggplot(data = WQ.NO3NO2.means, aes(x=factor(treatment, level = level_order_wq), y = response, colour = treatment)) + 
  geom_point(data = dislv_WQ, aes(x = treatment, y = NO3NO2), colour = "black", alpha = 0.2, size = 0.5, position = position_jitter(w = 0.1, h = 0)) +
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15), 
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(wq_labels, 12)) + 
  scale_y_continuous(expression(NO[3]+NO[2]~(µmol~L^-1))) + 
  scale_colour_manual(values=group.colors_wq) + 
  ggplot2::annotate(geom = "text", 
                    label = expression(NO[3]+NO[2]), 
                    size = 5, 
                    x = 0.5, 
                    y = Inf, 
                    hjust = 0, 
                    vjust = 1)
```

#####Means plot-no raw data

```{r}
#| label: model_investigations_2_NO2NO3_new
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.NO3NO2.means <- WQ.NO3NO2.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

#make plot that displays mean and HDCI
WQ_NO3NO2_plot_new <- ggplot(data = WQ.NO3NO2.means, aes(x=factor(treatment, level = level_order_wq_new), y = response, colour = treatment)) + 
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15, colour = "black"),
        axis.title.y = element_text(size = 11),
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(wq_labels_new, 12)) + 
  scale_y_continuous(expression(NO[3]+NO[2]~(µmol~L^-1)), 
                                limits = c(0.8, 1.8)) + 
  scale_colour_manual(values=group.colors_wq)
```

#####Pairwise investigations (Murray code)

```{r}
#| label: model_investigations_4_NO2NO3
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

sTreat <- WQ.NO3NO2.brm4$data |> pull(treatment) |> levels()
STreat <- rep(1, length(sTreat))
names(STreat) <- sTreat

WQ.NO3NO2.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = exp(.value)) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey"))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<0),
            Pg = mean(fit>0)) 
#absolute difference between the treatments


WQ.NO3NO2.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = log(exp(.value))) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = exp(t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey")))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<1),
            Pg = mean(fit>1))  
#this is the ratio of one treatment to another 
```

#PO4 
## Fit the model
###Treatment + 1|tank:sample random model 
####Priors model
```{r}
#| label: tank_samp_rand_model_1_PO4
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.PO4.form2 <- bf(PO4 ~ treatment + (1|tank_rep_rand:sample), family = gaussian()) 

priors <- prior(normal(0.17, 0.05), class = 'Intercept') + 
  prior(normal(0, 0.07), class = 'b') + 
  prior(student_t(3, 0, 0.05), class = 'sd') + 
  prior(student_t(3, 0, 0.05), class = 'sigma')
#prior(gamma(0.01, 0.01), class = 'shape')

WQ.PO4.brm3 <- brm(WQ.PO4.form2, 
                 data = dislv_WQ,
                 prior = priors, 
                 sample_prior = 'only',
                 iter = 10000, 
                 warmup = 2500, 
                 chains = 3, cores = 3, 
                 thin = 10, 
                 refresh = 0, 
                 seed = 123, 
                 control = list(adapt_delta = 0.99, max_treedepth = 20),
                 backend = "cmdstan") 

WQ.PO4.brm3 |> conditional_effects("treatment") |> plot(points = TRUE)   
#OK
```

####With data
```{r}
#| label: tank_samp_rand_model_2_PO4
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.PO4.brm4 <- WQ.PO4.brm3 |> update(sample_prior = "yes",
                                       refresh = 0, 
                                       iter = 10000,
                                       warmup = 2500,
                                       seed = 123) 

WQ.PO4.brm4 |> conditional_effects("treatment") |> plot(points = TRUE)

```

####MCMC sampling diagnostics

```{r}
#| label: tank_samp_rand_model_3_PO4
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: true 
pars <- WQ.PO4.brm4 |> get_variables()
pars_2 <- str_extract(pars, '^b_.*|^sd_.*|^sigma$') |> na.omit() 

#Traceplots
WQ.PO4.brm4$fit |> stan_trace(pars = pars_2, inc_warmup = TRUE)
#good 

#Autocorrelation
WQ.PO4.brm4$fit |> stan_ac(pars = pars_2) 
#good

#Rhat
WQ.PO4.brm4$fit |> stan_rhat()
#good

#ESS
WQ.PO4.brm4$fit |> stan_ess() 
#OK

summary(WQ.PO4.brm4) 
#good 

```

####Posterior probablity checks

```{r}
#| label: tank_samp_rand_model_4_PO4
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.PO4.brm4 |> pp_check(type = 'dens_overlay', ndraws = 200) + theme_classic()
```

####DHARMA residuals

```{r}
#| label: tank_samp_rand_model_5_PO4
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.resids <- make_brms_dharma_res(WQ.PO4.brm4, integerResponse = FALSE)

wrap_elements(~testUniformity(WQ.resids)) + 
  wrap_elements(~plotResiduals(WQ.resids, form = factor(rep(1, nrow(dislv_WQ))))) +
  wrap_elements(~plotResiduals(WQ.resids, quantreg = FALSE)) +
  wrap_elements(~testDispersion(WQ.resids))
```

####Model Investigations 
#####Summary

```{r}
#| label: model_investigations_1_PO4
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.PO4.brm4 |> 
  as_draws_df() |> 
  dplyr::select(matches('^b_.*|shape.*')) |> 
  summarise_draws(median, 
                  ~ HDInterval::hdi(.x, .width = 0.95),  
                  Pl = ~ mean(.x < 0), 
                  Pg = ~ mean(.x > 0),
                  "rhat", 
                  "ess_bulk", 
                  "ess_tail") |>
  knitr::kable()  

```

#####Means plot

```{r}
#| label: model_investigations_2_PO4
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.PO4.means <- WQ.PO4.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

#make plot that displays mean and HDCI
WQ_PO4_plot <- ggplot(data = WQ.PO4.means, aes(x=factor(treatment, level = level_order_wq), y = emmean, colour = treatment)) + 
  geom_point(data = dislv_WQ, aes(x = factor(treatment, level = level_order_wq), y = PO4), colour = "black", alpha = 0.2, size = 0.5, position = position_jitter(w = 0.1, h = 0)) +
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15), 
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(wq_labels, 12)) + 
  scale_y_continuous(expression(PO[4]~(umol~L^-1))) + 
  scale_colour_manual(values=group.colors_wq) + 
  ggplot2::annotate(geom = "text", 
                    label = expression("PO"[4]), 
                    size = 5, 
                    x = 0.5, 
                    y = Inf, 
                    hjust = 0, 
                    vjust = 1) 
```

#####Means plot-no raw data

```{r}
#| label: model_investigations_2_PO4_new
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.PO4.means <- WQ.PO4.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

#make plot that displays mean and HDCI
WQ_PO4_plot_new <- ggplot(data = WQ.PO4.means, aes(x=factor(treatment, level = level_order_wq_new), y = emmean, colour = treatment)) + 
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15, colour = "black"), 
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(wq_labels_new, 12)) + 
  scale_y_continuous(expression(PO[4]~(µmol~L^-1)), 
                                limits = c(0.12, 0.2)) + 
  scale_colour_manual(values=group.colors_wq)
```

#####Pairwise investigations (Murray code)

```{r}
#| label: model_investigations_4_NO2
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

sTreat <- WQ.PO4.brm4$data |> pull(treatment) |> levels()
STreat <- rep(1, length(sTreat))
names(STreat) <- sTreat

WQ.PO4.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = (.value)) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey"))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<0),
            Pg = mean(fit>0)) 
#absolute difference between the treatments


WQ.PO4.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = log((.value))) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = exp(t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey")))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<1),
            Pg = mean(fit>1))  
#this is the ratio of one treatment to another 
```

#DOC 
## Fit the model
###Treatment + 1|tank:sample random model 
####Priors model
```{r}
#| label: tank_samp_rand_model_1_DOC
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

#tested Gamma, gaussian, lognormal, lognormal with shift works best

WQ.DOC.form2 <- bf(DOC ~ treatment + (1|tank_rep_rand:sample), family = shifted_lognormal(link = "identity"), sigma ~ treatment)

priors_DOC <- prior(normal(-1.8, 0.6), class = 'Intercept') + 
  prior(normal(0, 0.5), class = 'b') + 
  prior(student_t(3, 0, 0.1), class = 'sd') +  
  prior(student_t(3, 0, 0.1), class = 'b', dpar = 'sigma') +
  prior(uniform(0, 0.91), class = 'ndt')

WQ.DOC.brm3 <- brm(WQ.DOC.form2, 
                 data = dislv_WQ_DOC_out,
                 prior = priors_DOC, 
                 sample_prior = 'only',
                 iter = 6000, 
                 warmup = 2500, 
                 chains = 3, cores = 3, 
                 thin = 10, 
                 refresh = 0, 
                 seed = 123, 
                 control = list(adapt_delta = 0.99, max_treedepth = 20),
                 backend = "cmdstan") 


WQ.DOC.brm3 |> conditional_effects("treatment") |> plot(points = TRUE)   
#OK 
```

####With data

```{r}
#| label: tank_samp_rand_model_2_DOC
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.DOC.brm4 <- WQ.DOC.brm3 |> update(sample_prior = "yes",
                                       refresh = 0, 
                                       iter = 10000,
                                       warmup = 2500,
                                       seed = 123) 

WQ.DOC.brm4 |> conditional_effects("treatment") |> plot(points = TRUE)

WQ.DOC.brm4 |> hypothesis("treatmentFish = 0") |> plot()

```

####MCMC sampling diagnostics

```{r}
#| label: tank_samp_rand_model_3_DOC
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: true 
pars <- WQ.DOC.brm4 |> get_variables()
pars_2 <- str_extract(pars, '^b_.*|^sigma$') |> na.omit() 

#Traceplots
WQ.DOC.brm4$fit |> stan_trace(pars = pars_2, inc_warmup = TRUE)
#good 

#Autocorrelation
WQ.DOC.brm4$fit |> stan_ac(pars = pars_2) 
#good

#Rhat
WQ.DOC.brm4$fit |> stan_rhat()
#good

#ESS
WQ.DOC.brm4$fit |> stan_ess() 
#OK

summary(WQ.DOC.brm4) 
#good 

```

####Posterior probablity checks

```{r}
#| label: tank_samp_rand_model_4_DOC
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.DOC.brm4 |> pp_check(type = 'dens_overlay', ndraws = 200) + theme_classic()
```

####DHARMA residuals

```{r}
#| label: tank_samp_rand_model_5_DOC
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.resids <- make_brms_dharma_res(WQ.DOC.brm4, integerResponse = FALSE)

wrap_elements(~testUniformity(WQ.resids)) + 
  #wrap_elements(~plotResiduals(WQ.resids, form = factor(rep(1, nrow(dislv_WQ))))) +
  wrap_elements(~plotResiduals(WQ.resids, quantreg = FALSE)) +
  wrap_elements(~testDispersion(WQ.resids))
```

####Model Investigations

#####Means plot

```{r}
#| label: model_investigations_2_DOC
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true
dislv_WQ_DOC_out <- dislv_WQ |> dplyr::filter(DOC < 10)

WQ.DOC.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

WQ.DOC.means <- WQ.DOC.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame() |>  
  mutate(summarise(group_by(dislv_WQ_DOC_out, treatment), median(DOC)), 
         emmean = exp(emmean) + 0.91, 
         lower.HPD = exp(lower.HPD) + 0.91,
         upper.HPD = exp(upper.HPD) + 0.91)

WQ_DOC_plot <- ggplot(data = WQ.DOC.means, aes(x=factor(treatment, level = level_order_wq), y = emmean, colour = treatment)) + 
  geom_point(data = dislv_WQ_DOC_out, aes(x = factor(treatment, level = level_order_wq), y = DOC), colour = "black", alpha = 0.4, size = 0.5, position = position_jitter(w = 0.1, h = 0)) +
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15)) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(wq_labels, 12)) + 
  scale_y_continuous(expression(DOC~(mg~L^-1))) + 
  scale_colour_manual(values=group.colors_wq) + 
  ggplot2::annotate(geom = "text", 
                    label = expression("DOC"), 
                    size = 5, 
                    x = 0.5, 
                    y = Inf, 
                    hjust = 0, 
                    vjust = 1)
```

#####Means plot-no raw data

```{r}
#| label: model_investigations_2_DOC_new
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.DOC.means <- WQ.DOC.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame() |>  
  mutate(summarise(group_by(dislv_WQ_DOC_out, treatment), median(DOC)), 
         emmean = exp(emmean) + 0.91, 
         lower.HPD = exp(lower.HPD) + 0.91,
         upper.HPD = exp(upper.HPD) + 0.91)

#make plot that displays mean and HDCI
WQ_DOC_plot_new <- ggplot(data = WQ.DOC.means, aes(x=factor(treatment, level = level_order_wq_new), y = emmean, colour = treatment)) + 
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15, colour = "black"), 
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(wq_labels_new, 12)) + 
  scale_y_continuous(expression(DOC~(mg~L^-1)), 
                                limits = c(1, 1.3)) + 
  scale_colour_manual(values=group.colors_wq)

```

#####Pairwise investigations (Murray code)
```{r}
#| label: model_investigations_4_PC
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

sTreat <- WQ.DOC.brm4$data |> pull(treatment) |> levels()
STreat <- rep(1, length(sTreat))
names(STreat) <- sTreat

WQ.DOC.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = exp(.value)+0.91) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey"))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<0),
            Pg = mean(fit>0)) 
#absolute difference between the treatments


WQ.PC.brm6 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = log(exp(.value))) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = exp(t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey")))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<1),
            Pg = mean(fit>1))  
#this is the ratio of one treatment to another 
```

#PN 
## Fit the model
###Treatment + 1|tank:sample random model 
####Priors model
```{r}
#| label: tank_samp_rand_model_1_PN
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.PN.form2 <- bf(PN ~ treatment + (1|tank_rep_rand:sample), family = Gamma(link = "log")) 

priors <- prior(normal(1.06, 0.6), class = 'Intercept') + 
  prior(normal(0, 0.6), class = 'b') + 
  prior(student_t(3, 0, 0.5), class = 'sd') + 
  #prior(student_t(3, 0, 0.1), class = 'sigma')
  prior(gamma(0.01, 0.01), class = 'shape')


WQ.PN.brm3 <- brm(WQ.PN.form2, 
                 data = part_WQ,
                 prior = priors, 
                 sample_prior = 'only',
                 iter = 10000, 
                 warmup = 2500, 
                 chains = 3, cores = 3, 
                 thin = 10, 
                 refresh = 0, 
                 seed = 123, 
                 control = list(adapt_delta = 0.99, max_treedepth = 20),
                 backend = "cmdstan") 


WQ.PN.brm3 |> conditional_effects("treatment") |> plot(points = TRUE)   
#OK 
```

####With data

```{r}
#| label: tank_samp_rand_model_2_PN
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.PN.brm4 <- WQ.PN.brm3 |> update(sample_prior = "yes",
                                       refresh = 0, 
                                       iter = 10000,
                                       warmup = 2500,
                                       seed = 123) 

WQ.PN.brm4 |> conditional_effects("treatment") |> plot(points = TRUE)
#OK

```

####MCMC sampling diagnostics

```{r}
#| label: tank_samp_rand_model_3_PN
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: true 
pars <- WQ.PN.brm4 |> get_variables()
pars_2 <- str_extract(pars, '^b_.*|^sd_.*|^shape$') |> na.omit() 

#Traceplots
WQ.PN.brm4$fit |> stan_trace(pars = pars_2, inc_warmup = TRUE)
#good 

#Autocorrelation
WQ.PN.brm4$fit |> stan_ac(pars = pars_2) 
#good

#Rhat
WQ.PN.brm4$fit |> stan_rhat()
#good

#ESS
WQ.PN.brm4$fit |> stan_ess() 
#OK

summary(WQ.PN.brm4) 
#good 

```

####Posterior probablity checks

```{r}
#| label: tank_samp_rand_model_4_PN
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.PN.brm4 |> pp_check(type = 'dens_overlay', ndraws = 200) + theme_classic()
#pretty good 
```

####DHARMA residuals

```{r}
#| label: tank_samp_rand_model_5_PN
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.resids <- make_brms_dharma_res(WQ.PN.brm4, integerResponse = FALSE)

wrap_elements(~testUniformity(WQ.resids)) + 
  #wrap_elements(~plotResiduals(WQ.resids, form = factor(rep(1, nrow(dislv_WQ))))) +
  wrap_elements(~plotResiduals(WQ.resids, quantreg = FALSE)) +
  wrap_elements(~testDispersion(WQ.resids))
#Good!

```

####Model Investigations 
#####Summary
```{r}
#| label: model_investigations_1_PN
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.PN.brm4 |> 
  as_draws_df() |> 
  dplyr::select(matches('^b_.*|shape.*')) |> 
  mutate(across(everything(), exp)) |> 
  summarise_draws(median, 
                  ~ HDInterval::hdi(.x, .width = 0.95),  
                  Pl = ~ mean(.x < 1), 
                  Pg = ~ mean(.x > 1),
                  "rhat", 
                  "ess_bulk", 
                  "ess_tail") |>
  knitr::kable()  

```

#####Means plot

```{r}
#| label: model_investigations_2_PN
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.PN.means <- WQ.PN.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

#make plot that displays mean and HDCI
WQ_PN_plot <- ggplot(data = WQ.PN.means, aes(x=factor(treatment, level = level_order_wq), y = response, colour = treatment)) + 
  geom_point(data = part_WQ, aes(x = factor(treatment, level = level_order_wq), y = PN), colour = "black", alpha = 0.4, size = 0.5, position = position_jitter(w = 0.1, h = 0)) +
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15)) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = c('Control', 'Dissolved_Coral', 'Dissolved_Fish', 'Fish', 'LiveFeeds', 'Mix', 'Pellets')) + 
  scale_y_continuous(expression(PN~(umol~L^-1))) + 
  scale_colour_manual(values=group.colors_wq) + 
  ggplot2::annotate(geom = "text", 
                    label = expression("PN"), 
                    size = 5, 
                    x = 0.5, 
                    y = Inf, 
                    hjust = 0, 
                    vjust = 1)
```

#####Means plot-no raw data

```{r}
#| label: model_investigations_2_PN_new
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.PN.means <- WQ.PN.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

#per L (samples are up per 250mL, so *4)
WQ.PN.means <- WQ.PN.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame() |> 
  mutate(response = 4*(response), 
         lower.HPD = 4*(lower.HPD),
         upper.HPD = 4*(upper.HPD))

(WQ.PN.means)

WQ_PN_plot_new <- ggplot(data = WQ.PN.means, aes(x=factor(treatment, level = level_order_wq_new), y = response, colour = treatment)) + 
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15, colour = "black"), 
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(wq_labels_new, 12)) + 
  scale_y_continuous(expression(PN~(µg~L^-1)), 
                                limits = c(8, 16)) + 
  scale_colour_manual(values=group.colors_wq)
```

#####Pairwise investigations (Murray code)

```{r}
#| label: model_investigations_4_PN
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

sTreat <- WQ.PN.brm4$data |> pull(treatment) |> levels()
STreat <- rep(1, length(sTreat))
names(STreat) <- sTreat

WQ.PN.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = exp(.value)) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey"))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<0),
            Pg = mean(fit>0)) 
#absolute difference between the treatments


WQ.PN.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = log(exp(.value))) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = exp(t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey")))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<1),
            Pg = mean(fit>1))  
#this is the ratio of one treatment to another 
```

#PC
####Remove outlier

```{r}
part_WQ_PC <- part_WQ |> dplyr::filter(PC < 60)

ggplot(part_WQ_PC, aes(y = PC, x = treatment, fill = treatment)) + 
  geom_boxplot() + 
  facet_grid(~tank) 
```

## Fit the model
###Treatment + 1|tank:sample random model 
####Priors model
```{r}
#| label: tank_samp_rand_model_1_PC_new
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.PC.form3 <- bf(PC ~ treatment + (1|tank_rep_rand:sample), family = Gamma(link = "log"), shape ~ treatment) 

priors <- prior(normal(2.56, 0.8), class = 'Intercept') + 
  prior(normal(0, 0.5), class = 'b') + 
  prior(student_t(3, 0, 0.8), class = 'sd') + 
  prior(normal(0, 1), class = 'b', dpar = 'shape')

WQ.PC.brm5 <- brm(WQ.PC.form3, 
                 data = part_WQ_PC,
                 prior = priors, 
                 sample_prior = 'only',
                 iter = 10000, 
                 warmup = 2500, 
                 chains = 3, cores = 3, 
                 thin = 10, 
                 refresh = 0, 
                 seed = 123, 
                 control = list(adapt_delta = 0.99, max_treedepth = 20),
                 backend = "cmdstan") 


WQ.PC.brm5 |> conditional_effects("treatment") |> plot(points = TRUE)    

#OK
```

####With data

```{r}
#| label: tank_samp_rand_model_2_PC_new
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.PC.brm6 <- WQ.PC.brm5 |> update(sample_prior = "yes",
                                       refresh = 500, 
                                       iter = 10000,
                                       warmup = 2500,
                                       seed = 123)  


WQ.PC.brm6 |> conditional_effects("treatment") |> plot(points = TRUE)
#OK 

WQ.PC.brm6 |> get_variables()
WQ.PC.brm6 |> hypothesis("shape_treatmentLiveFeeds = 0") |> plot()
#seems OK
```

####Posterior probablity checks

```{r}
#| label: tank_samp_rand_model_4_PC_new
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.PC.brm6 |> pp_check(type = 'dens_overlay', ndraws = 200) + theme_classic()
#bit better
```

####DHARMA residuals

```{r}
#| label: tank_samp_rand_model_5_PC_new
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.resids <- make_brms_dharma_res(WQ.PC.brm6, integerResponse = FALSE)

wrap_elements(~testUniformity(WQ.resids)) + 
  #wrap_elements(~plotResiduals(WQ.resids, form = factor(rep(1, nrow(dislv_WQ))))) +
  wrap_elements(~plotResiduals(WQ.resids, quantreg = FALSE)) +
  wrap_elements(~testDispersion(WQ.resids))
#Pretty good

```

####Model Investigations 
#####Summary
```{r}
#| label: model_investigations_1_PN
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.PC.brm6 |> 
  as_draws_df() |> 
  dplyr::select(matches('^b_.*|shape.*')) |> 
  summarise_draws(median, 
                  ~ HDInterval::hdi(.x, .width = 0.95),  
                  Pl = ~ mean(.x < 0), 
                  Pg = ~ mean(.x > 0),
                  "rhat", 
                  "ess_bulk", 
                  "ess_tail") |>
  knitr::kable()  

```

#####Means plot

```{r}
#| label: model_investigations_2_PC
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.PC.means <- WQ.PC.brm6 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

#make plot that displays mean and HDCI
WQ_PC_plot <- ggplot(data = WQ.PC.means, aes(x=factor(treatment, level = level_order_wq), y = response, colour = treatment)) + 
  geom_point(data = part_WQ, aes(x = factor(treatment, level = level_order_wq), y = PC), colour = "black", alpha = 0.4, size = 0.5, position = position_jitter(w = 0.1, h = 0)) +
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15)) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = c('Control', 'Dissolved_Coral', 'Dissolved_Fish', 'Fish', 'LiveFeeds', 'Mix', 'Pellets')) + 
  scale_y_continuous(expression(PC~(µg))) + 
  scale_colour_manual(values=group.colors_wq) + 
  ggplot2::annotate(geom = "text", 
                    label = expression("PC"), 
                    size = 5, 
                    x = 0.5, 
                    y = Inf, 
                    hjust = 0, 
                    vjust = 1)
```

#####Means plot-no raw data

```{r}
#| label: model_investigations_2_PN_new
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

#per L (samples are up per 250mL, so *4)
WQ.PC.means <- WQ.PC.brm6 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame() |> 
  mutate(response = 4*(response), 
         lower.HPD = 4*(lower.HPD),
         upper.HPD = 4*(upper.HPD))

WQ_PC_plot_new <- ggplot(data = WQ.PC.means, aes(x=factor(treatment, level = level_order_wq_new), y = response, colour = treatment)) + 
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15, colour = "black"), 
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(wq_labels_new, 12)) + 
  scale_y_continuous(expression(PC~(µg~L^-1)), 
                                limits = c(40, 80)) + 
  scale_colour_manual(values=group.colors_wq)

```

#####Summary

```{r}
#| label: model_investigations_1_PC_new
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.PC.brm6 |> 
  as_draws_df() |> 
  dplyr::select(matches('^b_.*|^sd_.*|shape.*')) |> 
  mutate(across(everything(), exp)) |> 
  summarise_draws(median, 
                  ~ HDInterval::hdi(.x, .width = 0.95),  
                  Pl = ~ mean(.x < 1), 
                  Pg = ~ mean(.x > 1),
                  "rhat", 
                  "ess_bulk", 
                  "ess_tail") |>
  knitr::kable()  

```

#####Pairwise investigations (Murray code)

```{r}
#| label: model_investigations_4_PC
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

sTreat <- WQ.PC.brm6$data |> pull(treatment) |> levels()
STreat <- rep(1, length(sTreat))
names(STreat) <- sTreat

WQ.PC.brm6 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = exp(.value)) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey"))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<0),
            Pg = mean(fit>0)) 
#absolute difference between the treatments


WQ.PC.brm6 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = log(exp(.value))) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = exp(t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey")))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<1),
            Pg = mean(fit>1))  
#this is the ratio of one treatment to another 
```

#PC/PN 
## Fit the model

###Treatment + 1|tank:sample random model 
####Priors model
```{r}
#| label: tank_samp_rand_model_1_PCN
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.PCN.form2 <- bf(PCN ~ treatment + (1|tank_rep_rand:sample), family = Gamma(link = "log")) 

priors <- prior(normal(1.68, 0.4), class = 'Intercept') + 
  prior(normal(0, 0.5), class = 'b') + 
  prior(student_t(3, 0, 0.2), class = 'sd') + 
  prior(gamma(0.01, 0.01), class = 'shape')

WQ.PCN.brm3 <- brm(WQ.PCN.form2, 
                 data = part_WQ_PCPN,
                 prior = priors, 
                 sample_prior = 'only',
                 iter = 10000, 
                 warmup = 2500, 
                 chains = 3, cores = 3, 
                 thin = 10, 
                 refresh = 0, 
                 seed = 123, 
                 control = list(adapt_delta = 0.99, max_treedepth = 20),
                 backend = "cmdstan") 


WQ.PCN.brm3 |> conditional_effects("treatment") |> plot(points = TRUE)   
#OK 
```

####With data

```{r}
#| label: tank_samp_rand_model_2_PCN
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.PCN.brm4 <- WQ.PCN.brm3 |> update(sample_prior = "yes",
                                       refresh = 0, 
                                       iter = 10000,
                                       warmup = 2500,
                                       seed = 123) 

WQ.PCN.brm4 |> conditional_effects("treatment") |> plot(points = TRUE)
#OK

WQ.PCN.brm4 |> get_variables()
WQ.PCN.brm4 |> hypothesis("treatmentLiveFeeds = 0") |> plot()
#seems OK
```

####Posterior probablity checks

```{r}
#| label: tank_samp_rand_model_4_PCN
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.PCN.brm4 |> pp_check(type = 'dens_overlay', ndraws = 200) + theme_classic()
#pretty good - use 0.01 is better than 2, 1 for shape 
#still not perfect fit
```

####MCMC sampling diagnostics

```{r}
#| label: tank_samp_rand_model_3_PCN
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: true 
pars <- WQ.PCN.brm4 |> get_variables()
pars_2 <- str_extract(pars, '^b_.*|^sd_.*|^shape$') |> na.omit() 

#Traceplots
WQ.PCN.brm4$fit |> stan_trace(pars = pars_2, inc_warmup = TRUE)
#good 

#Autocorrelation
WQ.PCN.brm4$fit |> stan_ac(pars = pars_2) 
#good

#Rhat
WQ.PCN.brm4$fit |> stan_rhat()
#good

#ESS
WQ.PCN.brm4$fit |> stan_ess() 
#OK

summary(WQ.PCN.brm4) 
#good 

```

####DHARMA residuals

```{r}
#| label: tank_samp_rand_model_5_PCN
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.resids <- make_brms_dharma_res(WQ.PCN.brm4, integerResponse = FALSE)

wrap_elements(~testUniformity(WQ.resids)) + 
  #wrap_elements(~plotResiduals(WQ.resids, form = factor(rep(1, nrow(dislv_WQ))))) +
  wrap_elements(~plotResiduals(WQ.resids, quantreg = FALSE)) +
  wrap_elements(~testDispersion(WQ.resids))
#OK, not perfect

```

####Model Investigations #####Summary

```{r}
#| label: model_investigations_1_PCN
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.PCN.brm4 |> 
  as_draws_df() |> 
  mutate(across(everything(), exp)) |> 
  dplyr::select(matches('^b_.*|shape.*')) |> 
  summarise_draws(median, 
                  ~ HDInterval::hdi(.x, .width = 0.95),  
                  Pl = ~ mean(.x < 1), 
                  Pg = ~ mean(.x > 1),
                  "rhat", 
                  "ess_bulk", 
                  "ess_tail") |>
  knitr::kable()  

```

#####Means plot

```{r}
#| label: model_investigations_2_PCN
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.PCN.means <- WQ.PCN.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

(WQ.PCN.means)

#make plot that displays mean and HDCI
WQ_PCN_plot <- ggplot(data = WQ.PCN.means, aes(x=factor(treatment, level = level_order_wq), y = response, colour = treatment)) + 
  geom_point(data = part_WQ_PCPN, aes(x = factor(treatment, level = level_order_wq), y = PCN), colour = "black", alpha = 0.4, size = 0.5, position = position_jitter(w = 0.1, h = 0)) +
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15)) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = c('Control', 'Dissolved_Coral', 'Dissolved_Fish', 'Fish', 'LiveFeeds', 'Mix', 'Pellets')) + 
  scale_y_continuous(expression(PC/PN~ratio)) + 
  scale_colour_manual(values=group.colors_wq)

WQ_PCN_plot 
```

#####Means plot-no raw data

```{r}
#| label: model_investigations_2_PCN_new
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.PCN.means <- WQ.PCN.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

WQ.PCN.means

WQ_PCN_plot_new <- ggplot(data = WQ.PCN.means, aes(x=factor(treatment, level = level_order_wq_new), y = response, colour = treatment)) + 
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15, colour = "black"), 
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(wq_labels_new, 12)) + 
  scale_y_continuous(expression(C:N), 
                                limits = c(4, 5.5)) + 
  scale_colour_manual(values=group.colors_wq)

WQ_PCN_plot_new  

```

#####Pairwise investigations (Murray code)

```{r}
#| label: model_investigations_4_PCN
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

sTreat <- WQ.PCN.brm4$data |> pull(treatment) |> levels()
STreat <- rep(1, length(sTreat))
names(STreat) <- sTreat

WQ.PCN.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = exp(.value)) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey"))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<0),
            Pg = mean(fit>0)) 
#absolute difference between the treatments

```


#NP ratio 
## Fit the model

###Treatment + 1|tank:sample random model 
####Priors model

```{r}
#| label: tank_samp_rand_model_1_NP
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.NP.form <- bf(NP ~ treatment + (1|tank_rep_rand:sample), family = Gamma(link = "log")) 

NP_priors <- prior(normal(1.87, 0.5), class = 'Intercept') + 
  prior(normal(0, 1), class = 'b') + 
  prior(student_t(3, 0, 0.5), class = 'sd') + 
  prior(gamma(0.01, 0.01), class = 'shape')

WQ.NP.brm1 <- brm(WQ.NP.form, 
                 data = dislv_WQ,
                 prior = NP_priors, 
                 sample_prior = 'only',
                 iter = 10000, 
                 warmup = 2500, 
                 chains = 3, cores = 3, 
                 thin = 10, 
                 refresh = 0, 
                 seed = 123, 
                 control = list(adapt_delta = 0.99, max_treedepth = 20),
                 backend = "cmdstan") 

WQ.NP.brm1 |> conditional_effects("treatment") |> plot(points = TRUE)   
#OK 
```

####With data

```{r}
#| label: tank_samp_rand_model_2_NP
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.NP.brm2 <- WQ.NP.brm1 |> update(sample_prior = "yes",
                                       refresh = 0, 
                                       iter = 10000,
                                       warmup = 2500,
                                       seed = 123) 

WQ.NP.brm2 |> conditional_effects("treatment") |> plot(points = TRUE)
#OK

WQ.NP.brm2 |> get_variables()
WQ.NP.brm2 |> hypothesis("treatmentLiveFeeds = 0") |> plot()
#seems OK
```

####Posterior probablity checks

```{r}
#| label: tank_samp_rand_model_4_NP
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.NP.brm2 |> pp_check(type = 'dens_overlay', ndraws = 200) + theme_classic()
#pretty good
```

####MCMC sampling diagnostics

```{r}
#| label: tank_samp_rand_model_3_NP
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: true 
pars <- WQ.NP.brm2 |> get_variables()
pars_2 <- str_extract(pars, '^b_.*|^sd_.*|^shape$') |> na.omit() 

#Traceplots
WQ.NP.brm2$fit |> stan_trace(pars = pars_2, inc_warmup = TRUE)
#good 

#Autocorrelation
WQ.NP.brm2$fit |> stan_ac(pars = pars_2) 
#good

#Rhat
WQ.NP.brm2$fit |> stan_rhat()
#good

#ESS
WQ.NP.brm2$fit |> stan_ess() 
#OK

summary(WQ.NP.brm2) 
#good 

```

####DHARMA residuals

```{r}
#| label: tank_samp_rand_model_5_NP
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.resids <- make_brms_dharma_res(WQ.NP.brm2, integerResponse = FALSE)

wrap_elements(~testUniformity(WQ.resids)) + 
  wrap_elements(~plotResiduals(WQ.resids, form = factor(rep(1, nrow(dislv_WQ))))) +
  wrap_elements(~plotResiduals(WQ.resids, quantreg = FALSE)) +
  wrap_elements(~testDispersion(WQ.resids))
#perfect

```

####Model Investigations 
#####Summary

```{r}
#| label: model_investigations_1_NP
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

WQ.NP.brm2 |> 
  as_draws_df() |> 
  mutate(across(everything(), exp)) |> 
  dplyr::select(matches('^b_.*|shape.*')) |> 
  summarise_draws(median, 
                  ~ HDInterval::hdi(.x, .width = 0.95),  
                  Pl = ~ mean(.x < 1), 
                  Pg = ~ mean(.x > 1),
                  "rhat", 
                  "ess_bulk", 
                  "ess_tail") |>
  knitr::kable()  

```

#####Means plot

```{r}
#| label: model_investigations_2_NP
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.NP.means <- WQ.NP.brm2 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

#make plot that displays mean and HDCI
WQ_NP_plot <- ggplot(data = WQ.NP.means, aes(x=factor(treatment, level = level_order_wq_new), y = response, colour = treatment)) + 
  geom_point(data = dislv_WQ, aes(x = factor(treatment, level = level_order_wq_new), y = NP), colour = "black", alpha = 0.4, size = 0.5, position = position_jitter(w = 0.1, h = 0)) +
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15)) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(wq_labels_new, 12)) + 
  scale_y_continuous(expression(N:P)) + 
  scale_colour_manual(values=group.colors_wq)
```

#####Means plot-no raw data

```{r}
#| label: model_investigations_2_NP_new
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

WQ.NP.means <- WQ.NP.brm2 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

WQ_NP_plot_b <- ggplot(data = WQ.NP.means, aes(x=factor(treatment, level = level_order_wq_new), y = response, colour = treatment)) + 
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15)) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(wq_labels_new, 12)) + 
  scale_y_continuous(expression(N:P)) + 
  scale_colour_manual(values=group.colors_wq)

```


#####Pairwise investigations (Murray code)

```{r}
#| label: model_investigations_4_NP
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

sTreat <- WQ.NP.brm2$data |> pull(treatment) |> levels()
STreat <- rep(1, length(sTreat))
names(STreat) <- sTreat

WQ.NP.brm2 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = exp(.value)) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey"))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<0),
            Pg = mean(fit>0))  

#absolute difference between the treatments

```
