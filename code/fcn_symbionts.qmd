---
title: "fcn_symbionts"
format: html
editor: source
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preparations
```{r Preperations}
#| label: libraries
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: false

library(tidyverse) #for data wrangling
library(cmdstanr)   #for cmdstan
library(brms)       #for fitting models in STAN
library(standist)   #for visualizing distributions
library(HDInterval) #for HPD intervals
library(posterior)  #for posterior draws
library(coda)       #for diagnostics
library(bayesplot)  #for diagnostics
library(ggmcmc)     #for MCMC diagnostics
library(rstan)      #for interfacing with STAN
library(effects)   #for partial effects plots
library(car)       #for regression diagnostics
library(broom)     #for tidy output
library(ggfortify) #for model diagnostics
library(sjPlot)    #for outputs
library(knitr)     #for kable
library(emmeans)   #for estimating marginal means
library(MASS)      #for glm.nb
library(MuMIn)     #for AICc
library(tidybayes)
library(broom.mixed)#for tidying MCMC outputs
library(patchwork)  #for multiple plots
library(ggeffects)
library(DHARMa)
library(ggridges)
library(bayestestR) #for ROPE
library(see)        #for some plots
library(easystats)    #framework for stats, modelling and visualisation 
library(dplyr)
library(scales)
source('../helperFunctions.R') 

``` 

#Read in data
```{r readData, results='markdown', eval=TRUE}
zoox_full <- read_csv('../data/corals_zoox.csv', trim_ws = TRUE)

zoox_full <- zoox_full |> mutate(treatment = factor(treatment),
                       tank_rep_rand = factor(tank_rep_rand), 
                       genotype = factor(genotype), 
                       fragment = factor(fragment))  

zoox_aten <- zoox_full |> dplyr::filter(species=="aten") |> droplevels() 
zoox_pdae <- zoox_full |> dplyr::filter(species=="pdae") |> droplevels() 
zoox_plut <- zoox_full |> dplyr::filter(species=="plut") |> droplevels() 
zoox_pver <- zoox_full |> dplyr::filter(species=="pver") |> droplevels() 

``` 


#Visualisation
```{r}
#| label: Visualisation_set-up
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

level_order_new <- c('Control','Pellets', 'LiveFeeds', 'Mix', 'Fish','Dissolved', 'Field', 'SeaSim')
level_order_new_nams <- c('Control','Pellets', 'LiveFeeds', 'LiveFeeds + Fish', 'Fish', 'Dissolved',  'Field', 'Post - acclimation') 

```

#Load models
```{r}
#| label: load models
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true
load("../models/pver.zooxSA.brm6.RData")
load("../models/aten.zooxSA.brm4.RData")
load("../models/plut.zooxSA.brm6.RData")
load("../models/pdae.zooxSA.brm4.RData")
```

#Pver 
## Fit the model 
###Treatment + tank random model
####Priors model
```{r}
#| label: tank_rand_model_1
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

pver.zooxSA.form3 <- bf(zoox_SA ~ treatment + (1|tank_rep_rand), family = gaussian()) 

priors <- prior(normal(1100000, 125000), class = 'Intercept') + 
  prior(normal(0, 1000000), class = 'b') + 
  prior(student_t(3, 0, 125000), 'sigma') + 
  prior(student_t(3, 0, 125000), class = 'sd')

pver.zooxSA.brm5 <- brm(pver.zooxSA.form3, 
                 data = zoox_pver,
                 prior = priors, 
                 sample_prior = 'only',
                 iter = 5000, 
                 warmup = 2500, 
                 chains = 3, cores = 3, 
                 thin = 5, 
                 refresh = 0, 
                 seed = 123, 
                 control = list(adapt_delta = 0.99),
                 backend = "cmdstan") 

pver.zooxSA.brm5 |> conditional_effects("treatment") |> plot(points = TRUE)   
#OK
```

####With data 
```{r}
#| label: tank_rand_model_2
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

pver.zooxSA.brm6 <- pver.zooxSA.brm5 |> update(sample_prior = "yes",
                                       refresh = 0, 
                                       iter = 6000,
                                       control = list(adapt_delta = 0.99),
                                       seed = 123) 

pver.zooxSA.brm6 |> conditional_effects("treatment") |> plot(points = TRUE)
#OK
```

####MCMC sampling diagnostics
```{r}
#| label: tank_rand_model_3
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: true 
pars <- pver.zooxSA.brm6 |> get_variables()
pars_2 <- str_extract(pars, '^b_.*|^sigma$') |> na.omit() 
pars_3 <- str_extract(pars, '^sigma$') |> na.omit() 

#Traceplots
pver.zooxSA.brm6$fit |> stan_trace(pars = pars_2, inc_warmup = TRUE)
#good 

#Autocorrelation
pver.zooxSA.brm6$fit |> stan_ac(pars = pars_2) 
#good

#Rhat
pver.zooxSA.brm6$fit |> stan_rhat()
#good

#ESS
pver.zooxSA.brm6$fit |> stan_ess() 
#OK

summary(pver.zooxSA.brm6) 
#ESS is OK  

```

####Posterior probablity checks
```{r}
#| label: tank_rand_model_4
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

pver.zooxSA.brm6 |> pp_check(type = 'dens_overlay', ndraws = 200) + theme_classic()
#OK
```

####DHARMA residuals
```{r}
#| label: tank_rand_model_5
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

coral.resids <- make_brms_dharma_res(pver.zooxSA.brm6, integerResponse = FALSE)

wrap_elements(~testUniformity(coral.resids)) + 
  wrap_elements(~plotResiduals(coral.resids, form = factor(rep(1, nrow(zoox_pver))))) +
  wrap_elements(~plotResiduals(coral.resids, quantreg = FALSE)) +
  wrap_elements(~testDispersion(coral.resids))
#Good
```

####Model Investigations
#####Summary
```{r}
#| label: model_investigations_1
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

pver.zooxSA.brm6 |> 
  as_draws_df() |> 
  dplyr::select(matches('^b_.*|^sigma$|^sd.*')) |> 
  summarise_draws(median, 
                  ~ HDInterval::hdi(.x, .width = 0.95),  
                  Pl = ~ mean(.x < 0), 
                  Pg = ~ mean(.x > 0),
                  "rhat", 
                  "ess_bulk", 
                  "ess_tail") |>
  knitr::kable()  
```

#####Means plot
```{r}
#| label: model_investigations_3
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true
pver.zoox.means <- pver.zooxSA.brm6 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

#make plot that displays mean and HDCI
pver_zoox_plot_noraw <-  ggplot(pver.zoox.means, aes(x=factor(treatment, level = level_order_new), y = emmean, colour = treatment)) +  
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15),
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(angle = 45, 
                                  vjust =1, 
                                   hjust = 1,
                                   colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(level_order_new_nams, 9)) + 
  scale_y_continuous(expression(Symbionts~(cm^-2)), labels=scales::label_scientific()) + 
  scale_colour_manual(values=group.colors)

```

#####Pairwise investigations (Murray code)
```{r}
#| label: model_investigations_4_pver
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

sTreat <- pver.zooxSA.brm6$data |> pull(treatment) |> levels()
STreat <- rep(1, length(sTreat))
names(STreat) <- sTreat

pver.zooxSA.brm6 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = .value) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey"))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  dplyr::summarise(median_hdci(fit),
            Pl = mean(fit<0),
            Pg = mean(fit>0)) 
#absolute difference between the treatments

pver.zooxSA.brm6 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = log((.value))) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = exp(t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey")))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  dplyr::summarise(median_hdci(fit),
            Pl = mean(fit<1),
            Pg = mean(fit>1))  -> pver_zoox_pwratio
#this is the ratio of one treatment to another 
```


#Aten 
## Fit the model 
###Treatment + tank random model
####Priors model
```{r}
#| label: tank_rand_model_1_aten
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

aten.zooxSA.form2 <- bf(zoox_SA ~ treatment + (1|tank_rep_rand), family = gaussian()) 

priors <- prior(normal(323000, 150000), class = 'Intercept') + 
  prior(normal(0, 700000), class = 'b') + 
  prior(student_t(3, 0, 150000), 'sigma') + 
  prior(student_t(3, 0, 150000), class = 'sd') 

aten.zooxSA.brm3 <- brm(aten.zooxSA.form2, 
                 data = zoox_aten,
                 prior = priors, 
                 sample_prior = 'only',
                 iter = 5000, 
                 warmup = 2500, 
                 chains = 3, cores = 3, 
                 thin = 5, 
                 refresh = 0, 
                 seed = 123, 
                 control = list(adapt_delta = 0.99),
                 backend = "cmdstan") 

aten.zooxSA.brm3 |> conditional_effects("treatment") |> plot(points = TRUE)   
#OK
```

####With data 
```{r}
#| label: tank_rand_model_2_aten
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

aten.zooxSA.brm4 <- aten.zooxSA.brm3 |> update(sample_prior = "yes",
                                       refresh = 0, 
                                       iter = 5000,
                                       warmup = 2500,
                                       seed = 123) 

aten.zooxSA.brm4 |> conditional_effects("treatment") |> plot(points = TRUE)
#OK
```

####MCMC sampling diagnostics
```{r}
#| label: tank_rand_model_3_aten
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: true 
pars <- aten.zooxSA.brm4 |> get_variables()
pars_2 <- str_extract(pars, '^b_.*|^sigma$') |> na.omit() 
pars_3 <- str_extract(pars, '^sigma$') |> na.omit() 

#Traceplots
aten.zooxSA.brm4$fit |> stan_trace(pars = pars_2, inc_warmup = TRUE)
#good 

#Autocorrelation
aten.zooxSA.brm4$fit |> stan_ac(pars = pars_2) 
#good 

#Rhat
aten.zooxSA.brm4$fit |> stan_rhat()
#good

#ESS
aten.zooxSA.brm4$fit |> stan_ess() 
#good

summary(aten.zooxSA.brm4) 
#good 

```

####Posterior probablity checks
```{r}
#| label: tank_rand_model_4_aten
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

aten.zooxSA.brm4 |> pp_check(type = 'dens_overlay', ndraws = 200) + theme_classic()
#OK 

```

####DHARMA residuals
```{r}
#| label: tank_rand_model_5_aten
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

coral.resids <- make_brms_dharma_res(aten.zooxSA.brm4, integerResponse = FALSE)

wrap_elements(~testUniformity(coral.resids)) + 
  wrap_elements(~plotResiduals(coral.resids, form = factor(rep(1, nrow(zoox_aten))))) +
  wrap_elements(~plotResiduals(coral.resids, quantreg = FALSE)) +
  wrap_elements(~testDispersion(coral.resids))
#Good
```

####Model Investigations
#####Summary
```{r}
#| label: model_investigations_1
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

aten.zooxSA.brm4 |> 
  as_draws_df() |> 
  dplyr::select(matches('^b_.*|^sigma$|^sd.*')) |> 
  summarise_draws(median, 
                  ~ HDInterval::hdi(.x, .width = 0.95),  
                  Pl = ~ mean(.x < 0), 
                  Pg = ~ mean(.x > 0),
                  "rhat", 
                  "ess_bulk", 
                  "ess_tail") |>
  knitr::kable()  

```

#####Means plot
```{r}
#| label: model_investigations_3
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

aten.zoox.means <- aten.zooxSA.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()


#make plot that displays mean and HDCI
aten_zoox_plot_noraw <-  ggplot(aten.zoox.means, aes(x=factor(treatment, level = level_order_new), y = emmean, colour = treatment)) +  
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15),
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(angle = 45, 
                                  vjust =1, 
                                   hjust = 1,
                                   colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(level_order_new_nams, 9)) + 
  scale_y_continuous(expression(Symbionts~(cm^-2)), 
                     labels=scales::label_scientific(), 
                     limits = c(200000, 1100000), 
                     breaks = c(200000, 400000, 600000, 800000, 1000000)) + 
  scale_colour_manual(values=group.colors)
```

#####Pairwise investigations (Murray code)
```{r}
#| label: model_investigations_4_aten
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

sTreat <- aten.zooxSA.brm4$data |> pull(treatment) |> levels()
STreat <- rep(1, length(sTreat))
names(STreat) <- sTreat

aten.zooxSA.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = .value) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey"))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<0),
            Pg = mean(fit>0)) 
#absolute difference between the treatments

aten.zooxSA.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = log((.value))) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = exp(t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey")))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<1),
            Pg = mean(fit>1))  
#this is the ratio of one treatment to another 
```

#Plut
## Fit the model 
###Treatment + tank random model
####Priors model
```{r}
#| label: tank_rand_model_1_plut
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

plut.zooxSA.form3 <- bf(zoox_SA ~ treatment + (1|tank_rep_rand), family = gaussian()) 

priors <- prior(normal(1650000, 1400000), class = 'Intercept') + 
  prior(normal(0, 1100000), class = 'b') + 
  prior(student_t(3, 0, 1100000), 'sigma') + 
  prior(student_t(3, 0, 1100000), class = 'sd')

plut.zooxSA.brm5 <- brm(plut.zooxSA.form3, 
                 data = zoox_plut,
                 prior = priors, 
                 sample_prior = 'only',
                 iter = 5000, 
                 warmup = 2500, 
                 chains = 3, cores = 3, 
                 thin = 5, 
                 refresh = 0, 
                 seed = 123, 
                 control = list(adapt_delta = 0.99),
                 backend = "cmdstan") 

plut.zooxSA.brm5 |> conditional_effects("treatment") |> plot(points = TRUE)   
#OK
```

####With data 
```{r}
#| label: tank_rand_model_2_plut
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

plut.zooxSA.brm6 <- plut.zooxSA.brm5 |> update(sample_prior = "yes",
                                       refresh = 0, 
                                       iter = 5000,
                                       warmup = 2500,
                                       seed = 123) 

plut.zooxSA.brm6 |> conditional_effects("treatment") |> plot(points = TRUE)
#OK
```

####MCMC sampling diagnostics
```{r}
#| label: tank_rand_model_3_plut
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: true 
pars <- plut.zooxSA.brm6 |> get_variables()
pars_2 <- str_extract(pars, '^b_.*|^sigma$') |> na.omit() 

#Traceplots
plut.zooxSA.brm6$fit |> stan_trace(pars = pars_2, inc_warmup = TRUE)
#good 

#Autocorrelation
plut.zooxSA.brm6$fit |> stan_ac(pars = pars_2) 
#good 

#Rhat
plut.zooxSA.brm6$fit |> stan_rhat()
#good

#ESS
plut.zooxSA.brm6$fit |> stan_ess() 
#good

summary(plut.zooxSA.brm6) 
#good 

```

####Posterior probablity checks
```{r}
#| label: tank_rand_model_4_plut
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

plut.zooxSA.brm6 |> pp_check(type = 'dens_overlay', ndraws = 200) + theme_classic()
#OK 
```

####DHARMA residuals
```{r}
#| label: tank_rand_model_5_plut
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

coral.resids <- make_brms_dharma_res(plut.zooxSA.brm6, integerResponse = FALSE)

wrap_elements(~testUniformity(coral.resids)) + 
  wrap_elements(~plotResiduals(coral.resids, form = factor(rep(1, nrow(zoox_plut))))) +
  wrap_elements(~plotResiduals(coral.resids, quantreg = FALSE)) +
  wrap_elements(~testDispersion(coral.resids))
#Good
```

####Model Investigations
#####Summary
```{r}
#| label: model_investigations_1_plut
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

plut.zooxSA.brm6 |> 
  as_draws_df() |> 
  dplyr::select(matches('^b_.*|^sigma$|^sd.*')) |> 
  summarise_draws(median, 
                  ~ HDInterval::hdi(.x, .width = 0.95),  
                  Pl = ~ mean(.x < 0), 
                  Pg = ~ mean(.x > 0),
                  "rhat", 
                  "ess_bulk", 
                  "ess_tail") |>
  knitr::kable()  
```

#####Means plot
```{r}
#| label: model_investigations_3
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

plut.zoox.means <- plut.zooxSA.brm6 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

#make plot that displays mean and HDCI
plut_zoox_plot_noraw <-  ggplot(plut.zoox.means, aes(x=factor(treatment, level = level_order_new), y = emmean, colour = treatment)) +  
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15),
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(angle = 45, 
                                  vjust =1, 
                                   hjust = 1,
                                   colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(level_order_new_nams, 9)) + 
  scale_y_continuous(expression(Symbionts~(cm^-2)), 
                     labels=scales::label_scientific(), 
                     limits = c(1000000, 3200000), 
                     #breaks = c(200000, 400000, 600000, 800000, 1000000)
                     ) + 
  scale_colour_manual(values=group.colors)
```
 
#####Pairwise investigations (Murray code)
```{r}
#| label: model_investigations_4_plut
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

sTreat <- plut.zooxSA.brm6$data |> pull(treatment) |> levels()
STreat <- rep(1, length(sTreat))
names(STreat) <- sTreat

plut.zooxSA.brm6 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = .value) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey"))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<0),
            Pg = mean(fit>0)) 
#absolute difference between the treatments

plut.zooxSA.brm6 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = log((.value))) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = exp(t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey")))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<1),
            Pg = mean(fit>1))  
#this is the ratio of one treatment to another 
```

#Pdae
## Fit the model 
###Treatment + tank random model
####Priors model
```{r}
#| label: tank_rand_model_1_pdae
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

pdae.zooxSA.form2 <- bf(zoox_SA ~ treatment + (1|tank_rep_rand), family = gaussian()) 

priors <- prior(normal(1100000, 260000), class = 'Intercept') + 
  prior(normal(0, 700000), class = 'b') + 
  prior(student_t(3, 0, 260000), 'sigma')+ 
  prior(student_t(3, 0, 260000), class = 'sd')

pdae.zooxSA.brm3 <- brm(pdae.zooxSA.form2, 
                 data = zoox_pdae,
                 prior = priors, 
                 sample_prior = 'only',
                 iter = 5000, 
                 warmup = 2500, 
                 chains = 3, cores = 3, 
                 thin = 5, 
                 refresh = 0, 
                 seed = 123, 
                 control = list(adapt_delta = 0.99),
                 backend = "cmdstan") 

pdae.zooxSA.brm3 |> conditional_effects("treatment") |> plot(points = TRUE)   
#OK
```

####With data 
```{r}
#| label: tank_rand_model_2_pdae
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

pdae.zooxSA.brm4 <- pdae.zooxSA.brm3 |> update(sample_prior = "yes",
                                       refresh = 0, 
                                       iter = 5000,
                                       warmup = 2500,
                                       seed = 123) 

pdae.zooxSA.brm4 |> conditional_effects("treatment") |> plot(points = TRUE)
#OK
```

####MCMC sampling diagnostics
```{r}
#| label: tank_rand_model_3_pdae
#| output: false
#| eval: true
#| warning: false
#| message: false
#| cache: true 
pars <- pdae.zooxSA.brm4 |> get_variables()
pars_2 <- str_extract(pars, '^b_.*|^sigma$') |> na.omit() 

#Traceplots
pdae.zooxSA.brm4$fit |> stan_trace(pars = pars_2, inc_warmup = TRUE)
#good 

#Autocorrelation
pdae.zooxSA.brm4$fit |> stan_ac(pars = pars_2) 
#good 

#Rhat
pdae.zooxSA.brm4$fit |> stan_rhat()
#good

#ESS
pdae.zooxSA.brm4$fit |> stan_ess() 
#good

summary(pdae.zooxSA.brm4) 
#good 

```

####Posterior probablity checks
```{r}
#| label: tank_rand_model_4_pdae
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

pdae.zooxSA.brm4 |> pp_check(type = 'dens_overlay', ndraws = 200) + theme_classic()
#OK 

```

####DHARMA residuals
```{r}
#| label: tank_rand_model_5_pdae
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

coral.resids <- make_brms_dharma_res(pdae.zooxSA.brm4, integerResponse = FALSE)

wrap_elements(~testUniformity(coral.resids)) + 
  wrap_elements(~plotResiduals(coral.resids, form = factor(rep(1, nrow(zoox_pdae))))) +
  wrap_elements(~plotResiduals(coral.resids, quantreg = FALSE)) +
  wrap_elements(~testDispersion(coral.resids))
#Good
```

####Model Investigations
#####Summary
```{r}
#| label: model_investigations_1_pdae
#| output: true
#| eval: true
#| warning: false
#| message: false
#| cache: true

pdae.zooxSA.brm4 |> 
  as_draws_df() |> 
  dplyr::select(matches('^b_.*|^sigma$|^sd.*')) |> 
  summarise_draws(median, 
                  ~ HDInterval::hdi(.x, .width = 0.95),  
                  Pl = ~ mean(.x < 0), 
                  Pg = ~ mean(.x > 0),
                  "rhat", 
                  "ess_bulk", 
                  "ess_tail") |>
  knitr::kable()  
```

#####Means plot
```{r}
#| label: model_investigations_3_pdae
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

pdae.zoox.means <- pdae.zooxSA.brm4 |> 
  emmeans(~treatment, type = 'response') |> 
  as.data.frame()

#make plot that displays mean and HDCI
pdae_zoox_plot_noraw <-  ggplot(pdae.zoox.means, aes(x=factor(treatment, level = level_order_new), y = emmean, colour = treatment)) +  
  geom_pointrange(aes(ymin = lower.HPD, ymax = upper.HPD), fatten = 5) + 
  theme_classic() +
  theme(legend.position = "none", 
        text = element_text(size=15),
        axis.text.y = element_text(colour = "black"), 
        axis.text.x = element_text(angle = 45, 
                                  vjust =1, 
                                   hjust = 1,
                                   colour = "black")) +
  scale_x_discrete(expression(Treatment), 
                   breaks = waiver(), 
                   labels = stringr::str_wrap(level_order_new_nams, 9)) + 
  scale_y_continuous(expression(Symbionts~(cm^-2)), 
                     labels=scales::label_scientific(), 
                     limits = c(300000, 1600000), 
                     #breaks = c(200000, 400000, 600000, 800000, 1000000)
                     ) + 
  scale_colour_manual(values=group.colors)
```
 
#####Pairwise investigations (Murray code)
```{r}
#| label: model_investigations_4_pdae
#| output: true
#| eval: true 
#| warning: false
#| message: false
#| cache: true

sTreat <- pdae.zooxSA.brm4$data |> pull(treatment) |> levels()
STreat <- rep(1, length(sTreat))
names(STreat) <- sTreat

pdae.zooxSA.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = .value) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey"))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<0),
            Pg = mean(fit>0)) 
#absolute difference between the treatments

pdae.zooxSA.brm4 |> emmeans(~treatment) |> 
  gather_emmeans_draws() |>  
  mutate(.value = log((.value))) |> 
  #filter(.draw == 1, month == 1) |> 
  ungroup() |>
  group_by(.draw) |> 
  reframe(fit = data.frame(contrast = rownames(multcomp::contrMat(n = STreat, type = "Tukey")), 
                           fit = exp(t(as.vector(.value) %*% t(multcomp::contrMat(n = STreat, type = "Tukey")))))) |> 
  unnest(fit) |> 
  group_by(contrast) |> 
  summarise(median_hdci(fit),
            Pl = mean(fit<1),
            Pg = mean(fit>1))  
#this is the ratio of one treatment to another 
```


#Helper functions
```{r dharma-resid}
make_brms_dharma_res <- function(brms_model, seed = 10, ...) {
                                        # equivalent to `simulateResiduals(lme4_model, use.u = FALSE)`
                                        # cores are set to 1 just to ensure reproducibility
    options(mc.cores = 1)
    on.exit(options(mc.cores = parallel::detectCores()))
    response <- brms::standata(brms_model)$Y
    ndraws <- nrow(as_draws_df(brms_model))
    manual_preds_brms <- matrix(0, ndraws, nrow(brms_model$data))
    random_terms <- insight::find_random(
                                 brms_model, split_nested = TRUE, flatten = TRUE
                             )
                                        # for this to have a similar output to `glmmTMB`'s default, we need to
                                        #   create new levels in the hierarchical variables, so then we can
                                        #   use `allow_new_levels = TRUE` and `sample_new_levels = "gaussian"` in
                                        #   `brms::posterior_epred`. This is equivalent to
                                        #   `simulateResiduals(lme4_model, use.u = FALSE)`. See details in
                                        #   `lme4:::simulate.merMod` and `glmmTMB:::simulate.glmmTMB`
    new_data <- brms_model$data |>
        dplyr::mutate(across(
                   all_of(random_terms), \(x)paste0("NEW_", x) |> as.factor()
               ))
    set.seed(seed)
    brms_sims <- brms::posterior_predict(
                           brms_model, re_formula = NULL, newdata = new_data,
                           allow_new_levels = TRUE, sample_new_levels = "gaussian"
                       ) |>
        t()
    fitted_median_brms <- apply(brms_sims, 1, median)
    ## fitted_median_brms <- apply(
    ##     t(brms::posterior_epred(brms_model, ndraws = ndraws, re.form = NA)),
    ##     1,
    ##     mean)
    DHARMa::createDHARMa(
                simulatedResponse = brms_sims,
                observedResponse = response,
                fittedPredictedResponse = fitted_median_brms,
                ...
            )
}


plot0.1 <- theme(axis.title.x = 
                   element_text(
                     margin = margin(t = 10),
                     color = "Black", 
                     size = 15), 
                 axis.title.y = 
                   element_text(
                     margin = margin(r = 20),
                     color = "Black", 
                     size = 15), 
                 axis.text = 
                   element_text(
                     color = "Black",
                     size = 12), 
                 axis.line = 
                   element_line(
                     color = "Black",
                     linewidth = 0.5), 
                 axis.ticks = element_line(color = "Black"),
                 panel.background = element_rect(fill = "grey98"),
                 panel.grid.minor = element_line(color = "White"),
                 plot.title = 
                   element_text(
                     size = 15,
                     face = "bold",
                     hjust = 0.5),
                 plot.subtitle = 
                   element_text(
                     size = 15,
                     hjust = 0.5),
                 strip.text.x = 
                   element_text(
                     size = 15,
                     color = "black", 
                     face = "bold"),
                 strip.background = 
                   element_rect(
                     color = "white",
                     fill = "white", 
                     linewidth = 1, 
                     linetype = "solid"),
                 legend.background = element_blank(), 
                 legend.title = 
                   element_text(
                     colour = "black",
                     size = 15, 
                     face = "bold"), 
                 legend.text = 
                   element_text(
                     colour = "black",
                     size = 12,
                     face = "bold.italic"),
                 legend.key.width = unit(1.5, "lines"), 
                 legend.key = element_rect(fill = NA))

# Same theme without a legend:
plot0 <- plot0.1 + theme(legend.position = "none")

autocor_check <- function(data,  modelTMB, variable, grouping, maxlag, n.sim) {
  
  data <- as.data.frame(data)
  
  if(missing(variable) || is.null(variable) ||  is.na(variable)) 
  {stop("ERROR: Temporal or spatial predictor missing. Please specify one, otherwise skip this step.")
  } else {
    
    if(length(variable) > 1) {   # dealing with spatial dependency here
      
      dists <- dist(data[, variable]) # this computes distance matrix 
      coord <- cbind(data[, variable[1]], data[, variable[2]])
      
      if(missing(maxlag) || is.null(maxlag) ||  is.na(maxlag)) {
        lags <- seq(min(dists), max(dists), length = 10) # set 10 lags at which to calculate semivariance  
      } else {lags <- seq(min(dists), max(maxlag), length = 10)}
      
      
    } else {
      
      if(!missing(grouping) && !is.null(grouping) &&  !is.na(grouping)) {  # dealing with multiple time series here  
        
        if(missing(maxlag) || is.null(maxlag) ||  is.na(maxlag)) {
          maxlag <- max(as.data.frame(data %>%
                                        group_by_at(grouping) %>%
                                        summarise(lag = max(!!sym(variable)) - min(!!sym(variable))))[,2])}
        
        new_time <- data[, variable] + maxlag * 3 * (as.integer(data[, grouping])-1)
        data$new_time <- new_time
        
        dists <- dist(cbind(new_time, rep(0, nrow(data)))) # this computes distance matrix   
        coord <- cbind(data$new_time, rep(0, nrow(data)))
        
        lags <- seq(min(dists), maxlag, length = 10) # set 10 lags at which to calculate semivariance  
        
      } else { # dealing with single time series here
        
        dists <- dist(cbind(data[, variable], rep(0, nrow(data)))) # this computes distance matrix   
        coord <- cbind(data[, variable], rep(0, nrow(data)))
        
        if(missing(maxlag) || is.null(maxlag) ||  is.na(maxlag)){
          lags <- seq(min(dists), max(dists), length = 10) # set 10 lags at which to calculate semivariance  
        } else {
          lags <- seq(min(dists), maxlag, length = 10)}
      }}
    if (class(modelTMB) %in% "glmmTMB") 
      res <- scale(residuals(modelTMB))
    if (class(modelTMB) %in% "brmsfit") 
      res <- scale(rowMeans(residuals(modelTMB)))
    data.Var <- as.data.frame(variog(coords = coord, 
                                     data = res, 
                                     breaks = lags)[c("u","v","n")])
    
    # Here we permute the observed semivariances across the observed pairwise distances (= grey lines in graph)
    data.rand.Var <- replicate(n.sim, variog(coords = coord, 
                                             data = sample(res, replace = F),
                                             breaks = lags)[c("v")])
    
    names(data.rand.Var) <- as.character(c(1:n.sim))
    data.rand.Var <- do.call(cbind.data.frame, data.rand.Var)
    data.rand.Var <- reshape::melt(data.rand.Var)
    data.rand.Var$u <- data.Var$u
    colnames(data.rand.Var) <- c("rep.run","v.rand","u")
    
    ggplot(data = data.Var, 
           aes(x = u, y = v)) + # this extracts distance lags and semi variance
      geom_line(data = data.rand.Var,
                aes(x = u, y = v.rand, 
                    group = rep.run), col = "grey80", size = 1, alpha = 0.5) +
      geom_point(col = "blue", size = 5, alpha = 0.5) +
      geom_smooth(method = "loess", se = F, col = "blue", size = 1) +
      geom_hline(yintercept = 1, col = "red", lty = 2) +
      xlab("Distance between observations") + 
      ylab("Standardised semivariance") +
      scale_y_continuous() +
      scale_x_continuous(breaks = data.Var$u, labels = formatC(round(data.Var$u, digits = 2), 2, format = "f")) +
      annotate("text", x = data.Var$u, y = min(c(data.rand.Var$v.rand,data.Var$v)) - 0.02*max(c(data.rand.Var$v.rand,data.Var$v)), label = c(paste("N =",data.Var$n[1]), data.Var$n[-1]), size = 5) +
      plot0
  }}




## The following is required to fix a bug in emmeans and brms for poly terms
## https://github.com/rvlenth/emmeans/issues/43
recover_data.brmsfit <- function(object, data, ...) {
    bt = brms::parse_bf(formula(object))
    if (class(bt) != "brmsterms")
        stop("This model is currently not supported.")
    trms <- attr(model.frame(bt$dpars$mu$fe, data = object$data), "terms")
    # we don't have a call component so I'll just put in NULL
    emmeans:::recover_data.call(NULL, trms, "na.omit", data = object$data, ...)
}

SUYR_prior_and_posterior <- function(mod) {
    dat <- mod$data
    terms <- attr(dat, 'terms')
    response <- all.vars(update(terms, .~ 1))
    predictors <- all.vars(terms)[-1]
    ## rhs <- mod$formula %>% as.formula %>% brms:::str_rhs()

    f <- mod$formula %>% as.formula %>% update(NULL ~.)
    rhs  <-
        deparse1(f) %>%
        str_remove("~") %>%
        ## paste(f[2],f[3],sep='~') %>%
        str_split("\\+") %>%
        unlist() %>%
        str_trim()
    rhs
    ## ## exclude any terms with a "|" or offset
    ## rhs <-
    ##     rhs[-grep("\\|",rhs)]
    wch.rnd <- rhs[grep("\\|", rhs)]
    if (length(wch.rnd)>0) f <- update(f, paste("~ . -",wch.rnd))
    no.offset <- function(x, preserve = NULL) {
      k <- 0
      proc <- function(x) {
        if (length(x) == 1) return(x)
        if (x[[1]] == as.name("offset") && !((k<<-k+1) %in% preserve)) return(x[[1]])
        replace(x, -1, lapply(x[-1], proc))
      }
      update(proc(x), ~ . - offset)
    }
    f <- no.offset(f)

    Xmat <- model.matrix(f, dat)[,-1] %>%
        as.matrix() %>% 
        colMeans() 
    ## if (length(Xmat)==1) Xmat <- Xmat %>% as.matrix()
    ## Xmat <- dat %>%
    ##     select(any_of(rhs)) %>%
    ##     summarise(across(everything(), mean)) %>%
    ##     as.matrix()

    b <- mod %>%
        as_draws_df() %>%
        dplyr::select(starts_with('b_'),
                      -contains('Intercept')) %>%
        as.matrix() %>%
        suppressWarnings()
    
    scal <- as.vector(Xmat %*% t(b))
    
    ## fixed effects
    brms_names <- brms:::change_effects(brmsterms(mod$formula),
                                        data = dat,
                                        pars = variables(mod))
    brms_names <- sapply(brms_names, function(x) str_remove(x$fnames, "b_"))
    priors <- mod %>% get_variables() %>% str_subset("^prior_.*") %>% str_subset("lprior", negate = TRUE) 
    pars <- mod %>% get_variables() %>%
        str_subset(paste0("^b_(Intercept|",paste0(brms_names,collapse="|"),")"))
    
    ## auxillary
    aux <- priors %>% str_subset("prior_(Intercept|b)", negate = TRUE) %>%
        str_remove("^prior_")
    pars <- c(pars, aux)
    ## random effects
    if (length(wch.rnd)>0) {
        ran.pars <- brms:::change_re(mod$ranef, pars = variables(mod))[[1]]$fnames
        pars <- c(pars, ran.pars)
    }
    variables(mod)

    vars <- variables(mod)
    priors <- vars %>% str_subset("prior") %>% str_subset("lprior", negate = TRUE)
    all.pars <- priors %>% str_remove("prior_")
    fixed.pars <- vars %>% str_subset("^b_")
    other.pars <- all.pars %>% str_subset("^Intercept$|^b$", negate = TRUE)
    other.pars <- vars %>% str_subset(paste0("^", other.pars, collapse = '|'))
    pars <- c(fixed.pars, other.pars)
    
    ## coefs <- prior_summary(mod)$class %>% unique()
    ## coefs.regex <- paste0("^b_", coefs, collapse = "|")
    
    mod.pp <- mod %>%
        as_draws_df() %>%
        dplyr::select(any_of(c(pars, priors))) %>%
        mutate(b_Intercept = b_Intercept + scal) %>%
        pivot_longer(cols=everything(), names_to='key', values_to='value') %>% 
        mutate(Type = ifelse(str_detect(key, 'prior'), 'Prior', 'Posterior'),
               Parameter = ifelse(Type == 'Prior',
                                  str_remove(key, "^prior_"),
                                  str_remove(key, "^b_")
                                  ),
               ## Parameter = ifelse(Type == 'Posterior',
               ##                     str_remove(Parameter, "__.*"),
               ##                    Parameter),
               Class = ifelse(Parameter %in% brms_names, 'b', Parameter),
               Class = ifelse(Type == 'Posterior', str_remove(Class, "__.*"), Class)) %>%
        suppressWarnings()

    return(
        ggplot(data = NULL, aes(x=Type,  y=value)) +
        stat_pointinterval(data = mod.pp %>% filter(Type == 'Prior')) +
        stat_pointinterval(data = mod.pp %>% filter(Type != 'Prior' & (Class != 'b' | Parameter == 'b')),
                           aes(colour = Parameter), position = position_dodge()) +
        stat_pointinterval(data = mod.pp %>% filter(Type != 'Prior' & (Class == 'b' & Parameter != 'b')),
                           aes(colour = Parameter), position = position_dodge())+
        facet_wrap(~Class,  scales='free')
        )
}
```